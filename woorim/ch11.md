# ch 11. 원시 값과 객체의 비교

## 1. 원시 값

---

### 변경 불가능한 값 immutable value

- 변수 값이 변경 불가능하다는 것이 아니라, 원시 값이 변경 불가능하다는 것이다.
- 변수 값을 변경하기 위해 원시 값을 재할당하면
  1. 새로운 메모리 공간을 확보하고 ,
  2. 재할당한 값을 저장한 후,
  3. 변수가 참조하던 메모리 공간의 주소를 변경한다.
- **불변성**을 갖는 원시 값을 할당한 변수는 값을 변경하기 위해서는 **재할당**을 해야한다.

### 문자열과 불변성

- 문자열: 0개 이상의 문자로 이뤄진 **집합**이며, 1개의 문자는 2바이트의 메모리 공간에 저장된다. 문자열이 몇 개의 문자로 이루어졌느냐에 따라 필요한 메모리 공간의 크기가 결정된다.
- 또 문자열은 **유사 배열 객체**이면서 **이터러블**이므로 배열과 유사하게 각 문자에 접근할 수 있다.

```jsx
var str = "string";

str[0] = "S"; // 에러가 발생하지 않는다.

console.log(str); // String

// 문자열은 원시 값이므로 문자열의 일부 문자를 변경해도 반영되지 않는다.
```

- 원시값은 어떤 일이 있어도 불변하기에, 예기치 못한 변경이 발생하지 않는다. 이는 **데이터의 신뢰성**을 보장한다.

### 값에 의한 전달

- 값에 의한 전달은 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 **원시 값이 복사되어** 전달되는 것을 말한다.

```jsx
var score = 80;
var copy = score;

console.log(score); // 80
console.log(copy); // 80

score = 100;

console.log(score); // 100
console.log(copy); // 80
```

- 위 코드에서 `copy`변수에 `score`를 할당하면 `copy`에는 `score`의 원시 값 `80`이 **복사되어** 전달된다. 둘이 갖는 숫자 값은 같지만, `score`변수와 `copy` 변수의 값 `80`은 다른 메모리 공간에 저장된 **별개의 값**이다.
- 사실은, 원시 값에 의한 전달이 아니라, 메모리 주소에 의한 전달이라고 할 수 있다. 변수 같은 \*식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.
  (단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.)

> \*식별자 : 어떤 값을 구별해서 식별해낼 수 있는 고유한 이름 = 메모리 주소에 붙인 이름

<aside>
💡 결국 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한 쪽에서 재할당을 통해 값을 변경하더라도 서로에게 영향을 줄 수없다!
</aside>

## 2. 객체

---

### 변경 가능한 값 mutable value

```jsx
var person = {
  name: "Lee",
};
```

- 객체를 할당한 변수가 기억하는 메모리 주소를 통해 **메모리 공간**에 접근하면 **\*참조 값 reference value**에 접근할 수 있다.

> - 참조 값: 생성된 객체가 저장된 메모리 공간의 주소

- 객체를 할당한 변수를 참조하면 1) 메모리에 저장되어 있는 2) 참조 값을 통해 **실제 객체**에 접근한다.

> _cf )_ 원시 값은 변수에 저장된 메모리 주소를 통해 **원시 값**에 접근

- 객체는 변경 가능한 값이므로, 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다.

> _cf)_ 원시 값을 갖는 변수의 값을 변경하려면 **재할당** 외에는 방법이 없다.

- 객체는 변경 가능한 값이므로 메모리에 저장된 객체를 직접 수정할 수 있다.
  이때 객체를 할당한 변수에 **재할당**을 하지 않았으므로 객체를 할당한 변수의 **참조 값**은 변경되지 않는다.

> _cf)_ `useState`에서 배열이나 객체같은 참조형 타입의 `state`를 바꿀 때, 스프레드 연산자(`…`)를 써서 새로운 배열 혹은 객체를 만들고 재할당을 해주는 이유!

- 메모리를 효율적으로 사용하기 위해, 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 객체는 변경 가능한 값으로 설계되어 있다.
- 이로인해, **여러 개의 식별자가 하나의 객체를 공유할 수 있다**는 부작용이 있다.

### 참조에 의한 전달

- 참조에 의한 전달: 객체가 가리키는 변수(person)를 다른 변수(copy)에 할당하면 원본의 참조 값이 복사되어 전달되는 것

  ```jsx
  var person = {
    name: "Lee",
  };

  var copy = person;
  ```

- 값에 의한 전달과 참조에 의한 전달은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 측면에서 동일하다.
- 다만 식별자가 기억하는 메모리 공간, 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이만 있을 뿐이다. 따라서 자바스크립트에는 참조에 의한 전달은 존재하지 않고 값에 의한 전달만 존재한다고 할 수 있다.

<aside>
💡 두 변수에 저장된 메모리 주소는 다르지만, 참조 값은 같다. 즉, 두 개의 식별자가 하나의 객체를 공유한다. 그래서 어느 한 쪽에서 객체를 변경하면, 그 변경 사항이 다른 한 쪽에게도 영향을 미친다.

</aside>
